cat ("\014")                                  #Clean the R console
# In this file: ================================================================
# 1. Verify terminology is of perception (perceiver-target) and not behavior.
# 2. Gather all illustrations output in a single location.
load("main.RImage")
load(imgName(".FullRR.ReadyforAPIM"))
ipak (c("psych", "tidyverse", "nlme", "lme4"))
pw <- nonScaledPW # Choose the right scaling option (only dyadic ratings and scores are scaled)
pw <- rename(pw, tDum = pDum, pDum = aDum, t.id = p.id, p.id = a.id)
idCols <- c("group.id", "p.id", "t.id", "dyad")
ptEffects <- apEffects
# Preparing the data ===========================================================
# Individual level
ind <- left_join(ptEffects, select(x, id=a.id, Age, starts_with("Self_Hum")), by = "id") %>%
distinct() %>%
mutate(Self_Humility = round(rowMeans(select(., starts_with("Self_Hum")), na.rm = TRUE), 2)) %>%
select(id, group.id, starts_with("Creat"), starts_with("Hum"), Age, Self_Humility)
# Dyadic level
dyads <- select(pw, all_of(idCols), starts_with("Creat"), starts_with("Hum")) %>%
mutate(di_Hum_ds.mean = rowMeans(select(., Hum_rel.AB, Hum_rel.BA), na.rm = TRUE),
di_Creat_ds.gap = abs(Creat_rel.AB - Creat_rel.BA),
di_Hum_target.product = Hum_target.A * Hum_target.B,
di_Creat_perc.product = Creat_perc.A * Creat_perc.B) %>%
mutate(across(starts_with("di_"), ~round(.x, digits = 3))) %>%
left_join(select(ind, p.id = id, Age.A = Age), by = "p.id") %>%
left_join(select(ind, t.id = id, Age.B = Age), by = "t.id") %>%
mutate(di_Age.mean = rowMeans(select(., Age.A, Age.B), na.rm = TRUE),
di_Age.gap = abs(Age.A - Age.B)) %>%
select(group.id, dyad, id1 = p.id, id2 = t.id, starts_with("di_")) %>%
group_by(dyad) %>% filter(row_number()==1) %>% ungroup %>%
setNames(gsub("di_", "", names(.))) %>%
select(group.id, dyad, id1, id2, starts_with("Creat"), starts_with("Hum"), everything())
# Directional dyadic level: pairwise 2-per-dyad entry
# Refine the dummy codes names for display purposes
a <- attr(pw$pDum, "dimnames")[2][[1]]
attr(pw$pDum, "dimnames")[2][[1]] <- gsub("pw\\$a\\.id", "pd", a)
a <- attr(pw$tDum, "dimnames")[2][[1]]
attr(pw$tDum, "dimnames")[2][[1]] <- gsub("pw\\$p\\.id", "td", a)
# Chose the relavant columns from pw for the demonstration
dPW <- pw %>%
select(all_of(idCols), starts_with("Creat_rel"), starts_with("Hum_rel"),
matches("Hum_target.(A|B)"), tDum, pDum)
# Directional dyadic level: pw 1-per-dyad entry
oneDyPW <- dPW %>%
# keep a single row per dyad
group_by(dyad) %>% filter(row_number()==1) %>% ungroup %>%
# keep only relevant columns
select(group.id, A.id=p.id, B.id=t.id, dyad, everything())
# dsAPIM implementation ========================================================
# Eq. (4) in methodology, Eq. 13 in illustrations.
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
pDum + tDum", mlMethod = "ML")
# Results: 0.16, 0.31 all significant.
# Eq. (5) in methodology, Eq. 14 in illustrations.
fit1 <- showAPIM("Creat_raw.AB ~ Hum_rel.AB + Hum_rel.BA +
pDum + tDum", mlMethod = "ML")
# The coefficients are the same as the ones of the prediction of uniqueness,
# so it's probably ok because the dyadic hum mostly affects only the dyadic creativity.
fit0 <- showAPIM("Creat_raw.AB ~ Hum_rel.AB + Hum_rel.BA +
Hum_rel.AB:pDum + Hum_rel.BA:tDum", mlMethod = "ML")
anova(fit0) # and we can see the interaction isn't significant.
# Eq. (6) in methodology, Eq. 15 in illustrations.
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
Safety_rel.AB + Safety_rel.BA +
pDum + tDum", mlMethod = "ML")
# Eq. (7) in methodology, Eq. 16 in illustrations.
# Create Target product in dPW.
dPW <- dPW %>% mutate(Hum_target.product = Hum_target.A * Hum_target.B) %>%
relocate(Hum_target.product, .before = any_of("tDum"))
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
Hum_target.product +
pDum + tDum", mlMethod = "REML", dataset = dPW)
# Eq. (8) in methodology, Eq. 17 in illustrations.
# Create other dyadic indices
dyads <- dyads %>%
left_join(select(ind, id1 = id, selfHum.A = Self_Humility), by = "id1") %>%
left_join(select(ind, id2 = id, selfHum.B = Self_Humility), by = "id2") %>%
mutate(Hum_self.mean = rowMeans(select(., selfHum.A, selfHum.B), na.rm = TRUE),
Hum_self.gap = abs(selfHum.A - selfHum.B)) %>%
select(group.id, dyad, id1, id2, starts_with("Creat"), starts_with("Hum"), everything())
dPW <- dPW %>% select(-contains("target")) %>%
left_join(select(dyads, dyad, starts_with("Hum_self"), starts_with("Age")),
by = "dyad") %>%
relocate(any_of(c("pDum", "tDum")), .after = last_col())
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
+ Hum_self.mean + Age.gap +
pDum + tDum", mlMethod = "REML", dataset = dPW)
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
+ Hum_self.mean + # Age.gap +
pDum + tDum", mlMethod = "REML", dataset = dPW)
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
#  + Hum_self.mean + # Age.gap +
pDum + tDum", mlMethod = "REML", dataset = dPW)
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
#  + Hum_self.mean +
Age.gap +
pDum + tDum", mlMethod = "REML", dataset = dPW)
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
#  + Hum_self.mean +
Age.mean +
pDum + tDum", mlMethod = "REML", dataset = dPW)
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
+ Hum_self.gap +
#  Age.mean +
pDum + tDum", mlMethod = "REML", dataset = dPW)
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
+ Hum_self.gap +
Age.mean +
pDum + tDum", mlMethod = "REML", dataset = dPW)
names(dPW)
# Chose the relavant columns from pw for the demonstration
dPW <- pw %>%
select(all_of(idCols), starts_with("Creat_rel"), starts_with("Hum_rel"),
matches("Hum_target.(A|B)"), tDum, pDum)
# Eq. (7) in methodology, Eq. 16 in illustrations.
# Create Target product in dPW.
dPW <- dPW %>% mutate(Hum_target.product = Hum_target.A * Hum_target.B) %>%
relocate(Hum_target.product, .before = any_of("tDum"))
dPW <- dPW %>% select(-contains("target")) %>%
left_join(select(dyads, dyad, "Hum_self.gap", "Age.mean")),
dPW <- dPW %>% select(-contains("target")) %>%
left_join(select(dyads, dyad, "Hum_self.gap", "Age.mean"),
by = "dyad") %>%
relocate(any_of(c("pDum", "tDum")), .after = last_col())
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
+ Hum_self.gap +
Age.mean +
pDum + tDum", mlMethod = "REML", dataset = dPW)
names(dyads)
# Dyadic level
dyads <- select(pw, all_of(idCols), starts_with("Creat"), starts_with("Hum")) %>%
mutate(di_Hum_ds.mean = rowMeans(select(., Hum_rel.AB, Hum_rel.BA), na.rm = TRUE),
di_Creat_ds.gap = abs(Creat_rel.AB - Creat_rel.BA),
di_Hum_target.product = Hum_target.A * Hum_target.B,
di_Creat_perc.product = Creat_perc.A * Creat_perc.B,
di_Hum_target.mean = mean(Hum_target.A, Hum_target.B) ) %>%
mutate(across(starts_with("di_"), ~round(.x, digits = 3))) %>%
left_join(select(ind, p.id = id, Age.A = Age, selfHum.A = Self_Humility), by = "p.id") %>%
left_join(select(ind, t.id = id, Age.B = Age, selfHum.B = Self_Humility), by = "t.id") %>%
mutate(di_Age.mean = rowMeans(select(., Age.A, Age.B), na.rm = TRUE),
di_Age.gap = abs(Age.A - Age.B),
di_Hum_self.mean = rowMeans(select(., selfHum.A, selfHum.B), na.rm = TRUE),
di_Hum_self.gap = abs(selfHum.A - selfHum.B)) %>%
select(group.id, dyad, id1 = p.id, id2 = t.id, starts_with("di_")) %>%
group_by(dyad) %>% filter(row_number()==1) %>% ungroup %>%
setNames(gsub("di_", "", names(.))) %>%
select(group.id, dyad, id1, id2, starts_with("Creat"), starts_with("Hum"), everything())
# Dyadic level
dyads <- select(pw, all_of(idCols), starts_with("Creat"), starts_with("Hum")) %>%
mutate(di_Hum_ds.mean = rowMeans(select(., Hum_rel.AB, Hum_rel.BA), na.rm = TRUE),
di_Creat_ds.gap = abs(Creat_rel.AB - Creat_rel.BA),
di_Hum_target.product = Hum_target.A * Hum_target.B,
di_Creat_perc.product = Creat_perc.A * Creat_perc.B,
di_Hum_target.mean = (Hum_target.A + Hum_target.B)/2 ) %>%
mutate(across(starts_with("di_"), ~round(.x, digits = 3))) %>%
left_join(select(ind, p.id = id, Age.A = Age, selfHum.A = Self_Humility), by = "p.id") %>%
left_join(select(ind, t.id = id, Age.B = Age, selfHum.B = Self_Humility), by = "t.id") %>%
mutate(di_Age.mean = rowMeans(select(., Age.A, Age.B), na.rm = TRUE),
di_Age.gap = abs(Age.A - Age.B),
di_Hum_self.mean = rowMeans(select(., selfHum.A, selfHum.B), na.rm = TRUE),
di_Hum_self.gap = abs(selfHum.A - selfHum.B)) %>%
select(group.id, dyad, id1 = p.id, id2 = t.id, starts_with("di_")) %>%
group_by(dyad) %>% filter(row_number()==1) %>% ungroup %>%
setNames(gsub("di_", "", names(.))) %>%
select(group.id, dyad, id1, id2, starts_with("Creat"), starts_with("Hum"), everything())
# Dyadic level
dyads <- select(pw, all_of(idCols), starts_with("Creat"), starts_with("Hum")) %>%
mutate(di_Hum_ds.mean = rowMeans(select(., Hum_rel.AB, Hum_rel.BA), na.rm = TRUE),
di_Creat_ds.gap = abs(Creat_rel.AB - Creat_rel.BA),
di_Hum_target.product = Hum_target.A * Hum_target.B,
di_Creat_perc.product = Creat_perc.A * Creat_perc.B,
di_Hum_target.mean = (Hum_target.A + Hum_target.B)/2 ) %>%
mutate(across(starts_with("di_"), ~round(.x, digits = 3))) %>%
left_join(select(ind, p.id = id, Age.A = Age, selfHum.A = Self_Humility), by = "p.id") %>%
left_join(select(ind, t.id = id, Age.B = Age, selfHum.B = Self_Humility), by = "t.id") %>%
mutate(di_Age.mean = rowMeans(select(., Age.A, Age.B), na.rm = TRUE),
di_Age.gap = abs(Age.A - Age.B),
di_SelfHum.mean = rowMeans(select(., selfHum.A, selfHum.B), na.rm = TRUE),
di_SelfHum.gap = abs(selfHum.A - selfHum.B)) %>%
select(group.id, dyad, id1 = p.id, id2 = t.id, starts_with("di_")) %>%
group_by(dyad) %>% filter(row_number()==1) %>% ungroup %>%
setNames(gsub("di_", "", names(.))) %>%
select(group.id, dyad, id1, id2, starts_with("Creat"), starts_with("Hum"), pDum, everything())
# Dyadic level
dyads <- select(pw, all_of(idCols), starts_with("Creat"), starts_with("Hum")) %>%
mutate(di_Hum_ds.mean = rowMeans(select(., Hum_rel.AB, Hum_rel.BA), na.rm = TRUE),
di_Creat_ds.gap = abs(Creat_rel.AB - Creat_rel.BA),
di_Hum_target.product = Hum_target.A * Hum_target.B,
di_Creat_perc.product = Creat_perc.A * Creat_perc.B,
di_Hum_target.mean = (Hum_target.A + Hum_target.B)/2 ) %>%
mutate(across(starts_with("di_"), ~round(.x, digits = 3))) %>%
left_join(select(ind, p.id = id, Age.A = Age, selfHum.A = Self_Humility), by = "p.id") %>%
left_join(select(ind, t.id = id, Age.B = Age, selfHum.B = Self_Humility), by = "t.id") %>%
mutate(di_Age.mean = rowMeans(select(., Age.A, Age.B), na.rm = TRUE),
di_Age.gap = abs(Age.A - Age.B),
di_SelfHum.mean = rowMeans(select(., selfHum.A, selfHum.B), na.rm = TRUE),
di_SelfHum.gap = abs(selfHum.A - selfHum.B)) %>%
select(group.id, dyad, id1 = p.id, id2 = t.id, starts_with("di_")) %>%
group_by(dyad) %>% filter(row_number()==1) %>% ungroup %>%
setNames(gsub("di_", "", names(.))) %>%
select(group.id, dyad, id1, id2, starts_with("Creat"), starts_with("Hum"), everything())
rm(list = ls())                               #Clean the Global Environment
cat ("\014")                                  #Clean the R console
# In this file: ================================================================
# 1. Verify terminology is of perception (perceiver-target) and not behavior.
# 2. Gather all illustrations output in a single location.
load("main.RImage")
load(imgName(".FullRR.ReadyforAPIM"))
ipak (c("psych", "tidyverse", "nlme", "lme4"))
pw <- nonScaledPW # Choose the right scaling option (only dyadic ratings and scores are scaled)
pw <- rename(pw, tDum = pDum, pDum = aDum, t.id = p.id, p.id = a.id)
idCols <- c("group.id", "p.id", "t.id", "dyad")
ptEffects <- apEffects
# Preparing the data ===========================================================
# Individual level
ind <- left_join(ptEffects, select(x, id=a.id, Age, starts_with("Self_Hum")), by = "id") %>%
distinct() %>%
mutate(Self_Humility = round(rowMeans(select(., starts_with("Self_Hum")), na.rm = TRUE), 2)) %>%
select(id, group.id, starts_with("Creat"), starts_with("Hum"), Age, Self_Humility)
# Dyadic level
dyads <- select(pw, all_of(idCols), starts_with("Creat"), starts_with("Hum")) %>%
mutate(di_Hum_ds.mean = rowMeans(select(., Hum_rel.AB, Hum_rel.BA), na.rm = TRUE),
di_Creat_ds.gap = abs(Creat_rel.AB - Creat_rel.BA),
di_Hum_target.product = Hum_target.A * Hum_target.B,
di_Creat_perc.product = Creat_perc.A * Creat_perc.B,
di_Hum_target.mean = (Hum_target.A + Hum_target.B)/2 ) %>%
mutate(across(starts_with("di_"), ~round(.x, digits = 3))) %>%
left_join(select(ind, p.id = id, Age.A = Age, selfHum.A = Self_Humility), by = "p.id") %>%
left_join(select(ind, t.id = id, Age.B = Age, selfHum.B = Self_Humility), by = "t.id") %>%
mutate(di_Age.mean = rowMeans(select(., Age.A, Age.B), na.rm = TRUE),
di_Age.gap = abs(Age.A - Age.B),
di_SelfHum.mean = rowMeans(select(., selfHum.A, selfHum.B), na.rm = TRUE),
di_SelfHum.gap = abs(selfHum.A - selfHum.B)) %>%
select(group.id, dyad, id1 = p.id, id2 = t.id, starts_with("di_")) %>%
group_by(dyad) %>% filter(row_number()==1) %>% ungroup %>%
setNames(gsub("di_", "", names(.))) %>%
select(group.id, dyad, id1, id2, starts_with("Creat"), starts_with("Hum"), everything())
# Directional dyadic level: pairwise 2-per-dyad entry
# Refine the dummy codes names for display purposes
a <- attr(pw$pDum, "dimnames")[2][[1]]
attr(pw$pDum, "dimnames")[2][[1]] <- gsub("pw\\$a\\.id", "pd", a)
a <- attr(pw$tDum, "dimnames")[2][[1]]
attr(pw$tDum, "dimnames")[2][[1]] <- gsub("pw\\$p\\.id", "td", a)
# Chose the relavant columns from pw for the demonstration
dPW <- pw %>%
select(all_of(idCols), starts_with("Creat_rel"), starts_with("Hum_rel"),
matches("Hum_target.(A|B)"), tDum, pDum)
# Directional dyadic level: pw 1-per-dyad entry
oneDyPW <- dPW %>%
# keep a single row per dyad
group_by(dyad) %>% filter(row_number()==1) %>% ungroup %>%
# keep only relevant columns
select(group.id, A.id=p.id, B.id=t.id, dyad, everything())
# dsAPIM implementation ========================================================
# Eq. (4) in methodology, Eq. 13 in illustrations.
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
pDum + tDum", mlMethod = "ML")
# Results: 0.16, 0.31 all significant.
# Eq. (5) in methodology, Eq. 14 in illustrations.
fit1 <- showAPIM("Creat_raw.AB ~ Hum_rel.AB + Hum_rel.BA +
pDum + tDum", mlMethod = "ML")
# The coefficients are the same as the ones of the prediction of uniqueness,
# so it's probably ok because the dyadic hum mostly affects only the dyadic creativity.
fit0 <- showAPIM("Creat_raw.AB ~ Hum_rel.AB + Hum_rel.BA +
Hum_rel.AB:pDum + Hum_rel.BA:tDum", mlMethod = "ML")
anova(fit0) # and we can see the interaction isn't significant.
# Eq. (6) in methodology, Eq. 15 in illustrations.
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
Safety_rel.AB + Safety_rel.BA +
pDum + tDum", mlMethod = "ML")
# Eq. (7) in methodology, Eq. 16 in illustrations.
# Create Target product in dPW.
dPW <- dPW %>% mutate(Hum_target.product = Hum_target.A * Hum_target.B) %>%
relocate(Hum_target.product, .before = any_of("tDum"))
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
Hum_target.product +
pDum + tDum", mlMethod = "REML", dataset = dPW)
# Eq. (8) in methodology, Eq. 17 in illustrations.
dPW <- dPW %>% select(-contains("target")) %>%
left_join(select(dyads, dyad, "Hum_self.gap", "Age.mean"), by = "dyad") %>%
relocate(any_of(c("pDum", "tDum")), .after = last_col())
dPW <- dPW %>% select(-contains("target")) %>%
left_join(select(dyads, dyad, "SelfHum.gap", "Age.mean"), by = "dyad") %>%
relocate(any_of(c("pDum", "tDum")), .after = last_col())
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
+ Hum_self.gap +
Age.mean +
pDum + tDum", mlMethod = "REML", dataset = dPW)
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
SelfHum.gap + Age.mean +
pDum + tDum", mlMethod = "REML", dataset = dPW)
dPW <- dPW %>% left_join(select(dyads, dyad, "Hum_target.mean"), by = "dyad") %>%
relocate(any_of(c("pDum", "tDum")), .after = last_col())
fit0 <- showAPIM("Creat_raw.AB ~ Hum_rel.AB + Hum_rel.BA +
+ Hum_target.mean + pDum + tDum", mlMethod = "ML", dataset = dPW)
rm(list = ls())                               #Clean the Global Environment
cat ("\014")                                  #Clean the R console
# In this file: ================================================================
# 1. Verify terminology is of perception (perceiver-target) and not behavior.
# 2. Gather all illustrations output in a single location.
load("main.RImage")
load(imgName(".FullRR.ReadyforAPIM"))
ipak (c("psych", "tidyverse", "nlme", "lme4"))
pw <- nonScaledPW # Choose the right scaling option (only dyadic ratings and scores are scaled)
pw <- rename(pw, tDum = pDum, pDum = aDum, t.id = p.id, p.id = a.id)
idCols <- c("group.id", "p.id", "t.id", "dyad")
ptEffects <- apEffects
# Preparing the data ===========================================================
# Individual level
ind <- left_join(ptEffects, select(x, id=a.id, Age, starts_with("Self_Hum")), by = "id") %>%
distinct() %>%
mutate(Self_Humility = round(rowMeans(select(., starts_with("Self_Hum")), na.rm = TRUE), 2)) %>%
select(id, group.id, starts_with("Creat"), starts_with("Hum"), Age, Self_Humility)
# Dyadic level
dyads <- select(pw, all_of(idCols), starts_with("Creat"), starts_with("Hum")) %>%
mutate(di_Hum_ds.mean = rowMeans(select(., Hum_rel.AB, Hum_rel.BA), na.rm = TRUE),
di_Creat_ds.gap = abs(Creat_rel.AB - Creat_rel.BA),
di_Hum_target.product = Hum_target.A * Hum_target.B,
di_Creat_perc.product = Creat_perc.A * Creat_perc.B,
di_Hum_target.mean = (Hum_target.A + Hum_target.B)/2 ) %>%
mutate(across(starts_with("di_"), ~round(.x, digits = 3))) %>%
left_join(select(ind, p.id = id, Age.A = Age, selfHum.A = Self_Humility), by = "p.id") %>%
left_join(select(ind, t.id = id, Age.B = Age, selfHum.B = Self_Humility), by = "t.id") %>%
mutate(di_Age.mean = rowMeans(select(., Age.A, Age.B), na.rm = TRUE),
di_Age.gap = abs(Age.A - Age.B),
di_SelfHum.mean = rowMeans(select(., selfHum.A, selfHum.B), na.rm = TRUE),
di_SelfHum.gap = abs(selfHum.A - selfHum.B)) %>%
select(group.id, dyad, id1 = p.id, id2 = t.id, starts_with("di_")) %>%
group_by(dyad) %>% filter(row_number()==1) %>% ungroup %>%
setNames(gsub("di_", "", names(.))) %>%
select(group.id, dyad, id1, id2, starts_with("Creat"), starts_with("Hum"), everything())
# Directional dyadic level: pairwise 2-per-dyad entry
# Refine the dummy codes names for display purposes
a <- attr(pw$pDum, "dimnames")[2][[1]]
attr(pw$pDum, "dimnames")[2][[1]] <- gsub("pw\\$a\\.id", "pd", a)
a <- attr(pw$tDum, "dimnames")[2][[1]]
attr(pw$tDum, "dimnames")[2][[1]] <- gsub("pw\\$p\\.id", "td", a)
# Chose the relavant columns from pw for the demonstration
dPW <- pw %>%
select(all_of(idCols), starts_with("Creat_rel"), starts_with("Hum_rel"),
matches("Hum_target.(A|B)"), tDum, pDum, Creat_raw.AB)
# Directional dyadic level: pw 1-per-dyad entry
oneDyPW <- dPW %>%
# keep a single row per dyad
group_by(dyad) %>% filter(row_number()==1) %>% ungroup %>%
# keep only relevant columns
select(group.id, A.id=p.id, B.id=t.id, dyad, everything())
# dsAPIM implementation ========================================================
# Eq. (4) in methodology, Eq. 13 in illustrations.
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
pDum + tDum", mlMethod = "ML", dataset = dPW)
# Eq. (5) in methodology, Eq. 14 in illustrations.
fit1 <- showAPIM("Creat_raw.AB ~ Hum_rel.AB + Hum_rel.BA +
pDum + tDum", mlMethod = "ML", dataset = dPW)
# The coefficients are the same as the ones of the prediction of uniqueness,
# so it's probably ok because the dyadic hum mostly affects only the dyadic creativity.
fit0 <- showAPIM("Creat_raw.AB ~ Hum_rel.AB + Hum_rel.BA +
Hum_rel.AB:pDum + Hum_rel.BA:tDum", mlMethod = "ML", dataset = dPW)
# Eq. (6) in methodology, Eq. 15 in illustrations.
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
Safety_rel.AB + Safety_rel.BA +
pDum + tDum", mlMethod = "ML", dataset = dPW)
rm(list = ls())                               #Clean the Global Environment
cat ("\014")                                  #Clean the R console
# In this file: ================================================================
# 1. Verify terminology is of perception (perceiver-target) and not behavior.
# 2. Gather all illustrations output in a single location.
load("main.RImage")
load(imgName(".FullRR.ReadyforAPIM"))
ipak (c("psych", "tidyverse", "nlme", "lme4"))
pw <- nonScaledPW # Choose the right scaling option (only dyadic ratings and scores are scaled)
pw <- rename(pw, tDum = pDum, pDum = aDum, t.id = p.id, p.id = a.id)
idCols <- c("group.id", "p.id", "t.id", "dyad")
ptEffects <- apEffects
# Preparing the data ===========================================================
# Individual level
ind <- left_join(ptEffects, select(x, id=a.id, Age, starts_with("Self_Hum")), by = "id") %>%
distinct() %>%
mutate(Self_Humility = round(rowMeans(select(., starts_with("Self_Hum")), na.rm = TRUE), 2)) %>%
select(id, group.id, starts_with("Creat"), starts_with("Hum"), Age, Self_Humility)
# Dyadic level
dyads <- select(pw, all_of(idCols), starts_with("Creat"), starts_with("Hum")) %>%
mutate(di_Hum_ds.mean = rowMeans(select(., Hum_rel.AB, Hum_rel.BA), na.rm = TRUE),
di_Creat_ds.gap = abs(Creat_rel.AB - Creat_rel.BA),
di_Hum_target.product = Hum_target.A * Hum_target.B,
di_Creat_perc.product = Creat_perc.A * Creat_perc.B,
di_Hum_target.mean = (Hum_target.A + Hum_target.B)/2 ) %>%
mutate(across(starts_with("di_"), ~round(.x, digits = 3))) %>%
left_join(select(ind, p.id = id, Age.A = Age, selfHum.A = Self_Humility), by = "p.id") %>%
left_join(select(ind, t.id = id, Age.B = Age, selfHum.B = Self_Humility), by = "t.id") %>%
mutate(di_Age.mean = rowMeans(select(., Age.A, Age.B), na.rm = TRUE),
di_Age.gap = abs(Age.A - Age.B),
di_SelfHum.mean = rowMeans(select(., selfHum.A, selfHum.B), na.rm = TRUE),
di_SelfHum.gap = abs(selfHum.A - selfHum.B)) %>%
select(group.id, dyad, id1 = p.id, id2 = t.id, starts_with("di_")) %>%
group_by(dyad) %>% filter(row_number()==1) %>% ungroup %>%
setNames(gsub("di_", "", names(.))) %>%
select(group.id, dyad, id1, id2, starts_with("Creat"), starts_with("Hum"), everything())
# Directional dyadic level: pairwise 2-per-dyad entry
# Refine the dummy codes names for display purposes
a <- attr(pw$pDum, "dimnames")[2][[1]]
attr(pw$pDum, "dimnames")[2][[1]] <- gsub("pw\\$a\\.id", "pd", a)
a <- attr(pw$tDum, "dimnames")[2][[1]]
attr(pw$tDum, "dimnames")[2][[1]] <- gsub("pw\\$p\\.id", "td", a)
# Chose the relavant columns from pw for the demonstration
dPW <- pw %>%
select(all_of(idCols), starts_with("Creat_rel"), starts_with("Hum_rel"),
matches("Hum_target.(A|B)"), tDum, pDum, Creat_raw.AB, starts_with("Safety_rel"))
# Directional dyadic level: pw 1-per-dyad entry
oneDyPW <- dPW %>%
# keep a single row per dyad
group_by(dyad) %>% filter(row_number()==1) %>% ungroup %>%
# keep only relevant columns
select(group.id, A.id=p.id, B.id=t.id, dyad, everything())
# dsAPIM implementation ========================================================
# Eq. (4) in methodology, Eq. 13 in illustrations.
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
pDum + tDum", mlMethod = "ML", dataset = dPW)
# Eq. (5) in methodology, Eq. 14 in illustrations.
fit1 <- showAPIM("Creat_raw.AB ~ Hum_rel.AB + Hum_rel.BA +
pDum + tDum", mlMethod = "ML", dataset = dPW)
# The coefficients are the same as the ones of the prediction of uniqueness,
# so it's probably ok because the dyadic hum mostly affects only the dyadic creativity.
fit0 <- showAPIM("Creat_raw.AB ~ Hum_rel.AB + Hum_rel.BA +
Hum_rel.AB:pDum + Hum_rel.BA:tDum", mlMethod = "ML", dataset = dPW)
anova(fit0) # and we can see the interaction isn't significant.
# Eq. (6) in methodology, Eq. 15 in illustrations.
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
Safety_rel.AB + Safety_rel.BA +
pDum + tDum", mlMethod = "ML", dataset = dPW)
# Eq. (7) in methodology, Eq. 16 in illustrations.
# Create Target product in dPW.
dPW <- dPW %>% mutate(Hum_target.product = Hum_target.A * Hum_target.B) %>%
relocate(Hum_target.product, .before = any_of("tDum"))
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
Hum_target.product +
pDum + tDum", mlMethod = "REML", dataset = dPW)
dPW <- dPW %>%
left_join(select(dyads, dyad, "SelfHum.gap", "Age.mean"), by = "dyad") %>%
relocate(any_of(c("pDum", "tDum")), .after = last_col()) %>%
relocate(contains("target"), .after = last_col())
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
SelfHum.gap + Age.mean +
pDum + tDum", mlMethod = "REML", dataset = dPW)
dPW <- dPW %>% left_join(select(dyads, dyad, "Hum_target.mean"), by = "dyad") %>%
relocate(any_of(c("pDum", "tDum")), .after = last_col())
fit0 <- showAPIM("Creat_raw.AB ~ Hum_rel.AB + Hum_rel.BA +
+ Hum_target.mean + pDum + tDum", mlMethod = "ML", dataset = dPW)
fit0 <- showAPIM("Creat_raw.AB ~ Hum_rel.AB + Hum_rel.BA +
Hum_target.mean + pDum + tDum", mlMethod = "ML", dataset = dPW)
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
Hum_perc.A:Hum_perc.B  + pDum + tDum", mlMethod = "ML", dataset = dPW)
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
Hum_target.A:Hum_target.B  + pDum + tDum", mlMethod = "ML", dataset = dPW)
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
Hum_target.A:Hum_target.B:SelfHum.gap  + pDum + tDum", mlMethod = "ML", dataset = dPW)
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
Hum_target.product:SelfHum.gap  + pDum + tDum", mlMethod = "ML", dataset = dPW)
?gls
# Dyadic level
dyads <- select(pw, all_of(idCols), starts_with("Creat"), starts_with("Hum")) %>%
mutate(di_Hum_ds.mean = rowMeans(select(., Hum_rel.AB, Hum_rel.BA), na.rm = TRUE),
di_Creat_ds.gap = abs(Creat_rel.AB - Creat_rel.BA),
di_Hum_target.product = Hum_target.A * Hum_target.B,
di_Creat_perc.product = Creat_perc.A * Creat_perc.B,
di_Hum_target.mean = (Hum_target.A + Hum_target.B)/2 ) %>%
mutate(across(starts_with("di_"), ~round(.x, digits = 3))) %>%
left_join(select(ind, p.id = id, Age.A = Age, selfHum.A = Self_Humility), by = "p.id") %>%
left_join(select(ind, t.id = id, Age.B = Age, selfHum.B = Self_Humility), by = "t.id") %>%
mutate(di_Age.mean = rowMeans(select(., Age.A, Age.B), na.rm = TRUE),
di_Age.gap = abs(Age.A - Age.B),
di_SelfHum.mean = rowMeans(select(., selfHum.A, selfHum.B), na.rm = TRUE),
di_SelfHum.gap = abs(selfHum.A - selfHum.B)) %>%
select(group.id, dyad, starts_with("di_")) %>%
group_by(dyad) %>% filter(row_number()==1) %>% ungroup %>%
setNames(gsub("di_", "", names(.))) %>%
select(group.id, dyad, starts_with("Creat"), starts_with("Hum"), everything())
# Eq. (4) in methodology, Eq. 13 in illustrations.
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
pDum + tDum", mlMethod = "ML", dataset = dPW)
fit
# dsAPIM implementation ========================================================
# general demo of code
# The formula:  Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA + pDum + tDum
# The gls code:
fit <- gls(Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA + pDum + tDum,
na.action = na.omit,
method = "REML",
correlation = corCompSymm (form = ~1|dyad),
data = pw)
fit
fit
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
pDum + tDum", mlMethod = "ML", dataset = dPW)
# Eq. (4) in methodology, Eq. 13 in illustrations.
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
pDum + tDum", mlMethod = "REML", dataset = dPW)
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
pDum + tDum", dataset = dPW)
fit0 <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
pDum + tDum", dataset = dPW)
fit <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA +
pDum + tDum", dataset = dPW)
fit <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA + pDum + tDum",
dataset = dPW)
fit <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA + pDum + tDum", dataset = dPW)
fit <- showAPIM("Creat_rel.AB ~ Hum_rel.AB + Hum_rel.BA + pDum + tDum", dataset = dPW)
rm(list = ls())                              #Clean the Global Environment
cat ("\014")                                 #Clean the R console
if (is.null(dev.list()) == FALSE) dev.off()  #Clean Plots
options(scipen = 10)                         #Avoid scientific notation for up to 10 digits
.lib()
